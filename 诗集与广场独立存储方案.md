# 诗集与广场独立存储方案

## 🎯 问题描述

**原问题**：在【我的诗集】里编辑诗歌后，广场上的诗歌也跟着改变了。

**根本原因**：
- 诗集和广场共用**同一个 `Poem` 对象**（通过 `id` 索引）
- 只通过 `inMyCollection` 和 `inSquare` 两个布尔标志区分位置
- 编辑时调用 `savePoem()` 会直接修改这个对象，影响所有引用

---

## ✅ 解决方案

### 核心思路：**发布时创建副本**

发布到广场时，创建一个**全新的 `Poem` 副本**（新的 `id`），而不是修改原诗歌的标志位。

```
诗集中的诗                         广场上的诗
┌────────────┐                    ┌────────────┐
│ id: ABC123 │  ──发布时创建副本──→ │ id: XYZ789 │
│ title: xxx │                    │ title: xxx │
│ content:.. │                    │ content:.. │
│ squareId:  │                    │ squareId:  │
│   XYZ789   │←────关联────────────│   XYZ789   │
└────────────┘                    └────────────┘
  inMyCollection: true              inSquare: true
  inSquare: false                   inMyCollection: false
```

---

## 🔄 新的发布逻辑

### 修改前（有问题）

```swift
func publishToSquare(_ poem: Poem) throws {
    if let index = allPoems.firstIndex(where: { $0.id == poem.id }) {
        var publishedPoem = allPoems[index]
        publishedPoem.inSquare = true  // ❌ 只是修改标志位
        allPoems[index] = publishedPoem
    }
}
```

**问题**：诗集和广场是同一个对象，编辑诗集会影响广场。

---

### 修改后（正确）

```swift
func publishToSquare(_ poem: Poem) throws {
    // 1. 检查相似度
    if let similarPoem = try checkSimilarity(for: poem) {
        throw PoemPublishError.similarContentExists(title: similarPoem.title)
    }
    
    // 2. 创建广场上的新副本（新的 ID）
    let squareId = UUID().uuidString
    let squareCopy = Poem(
        id: UUID().uuidString,        // ✅ 新的 ID
        title: poem.title,
        content: poem.content,
        authorName: poem.authorName,
        // ... 其他字段 ...
        inMyCollection: false,        // 广场副本不在诗集中
        inSquare: true,               // 在广场中
        squareId: squareId,
        squarePublishedAt: Date(),
        squareLikeCount: 0
    )
    
    // 3. 添加广场副本
    allPoems.append(squareCopy)
    
    // 4. 更新诗集中的原诗歌，记录 squareId（用于关联）
    if let index = allPoems.firstIndex(where: { $0.id == poem.id }) {
        var updatedOriginal = allPoems[index]
        updatedOriginal.squareId = squareId  // ✅ 记录关联
        updatedOriginal.squarePublishedAt = Date()
        allPoems[index] = updatedOriginal
    }
    
    savePoems()
}
```

---

## 📊 数据结构说明

### `Poem` 关键字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | String | **诗歌的唯一标识**<br>诗集和广场的诗歌有不同的 `id` |
| `inMyCollection` | Bool | 是否在【我的诗集】中 |
| `inSquare` | Bool | 是否在【广场】中 |
| `squareId` | String? | **关联字段**<br>- 诗集中的诗：记录广场副本的 `id`<br>- 广场中的诗：自己的 `id` |
| `squarePublishedAt` | Date? | 发布到广场的时间 |
| `squareLikeCount` | Int | 广场上的点赞数 |

---

## 🔄 完整的状态流转

### 场景 1：创作并保存到诗集

```
用户写诗
   ↓
点击【保存】
   ↓
Poem(id: A, inMyCollection: true, inSquare: false, squareId: nil)
   ↓
进入【我的-诗集】
```

---

### 场景 2：发布到广场

```
诗集中的诗：Poem(id: A, inMyCollection: true, squareId: nil)
   ↓
点击【发布到广场】
   ↓
创建广场副本：Poem(id: B, inSquare: true, squareId: B)
更新诗集原诗：Poem(id: A, inMyCollection: true, squareId: B)
   ↓
诗集：Poem A（显示【已发布广场】灰色按钮）
广场：Poem B（可被其他用户看到和点赞）
```

---

### 场景 3：编辑诗集中的诗

```
诗集：Poem A (title: "城市夜晚", squareId: B)
广场：Poem B (title: "城市夜晚")
   ↓
编辑诗集中的 Poem A，改标题为"城市清晨"
   ↓
调用 savePoem(Poem A)
   ↓
只更新 Poem A，Poem B 不受影响
   ↓
诗集：Poem A (title: "城市清晨", squareId: B)  ✅ 已修改
广场：Poem B (title: "城市夜晚")              ✅ 保持不变
```

**结果**：诗集和广场互不影响！✅

---

### 场景 4：从诗集删除

```
诗集：Poem A (squareId: B)
广场：Poem B
   ↓
从诗集删除 Poem A
   ↓
allPoems.remove(Poem A)
   ↓
诗集：（空）
广场：Poem B  ✅ 仍然存在
```

---

### 场景 5：从广场删除

```
诗集：Poem A (squareId: B)
广场：Poem B
   ↓
从广场删除 Poem B
   ↓
allPoems.remove(Poem B)
更新 Poem A 的 squareId = nil
   ↓
诗集：Poem A (squareId: nil)  ✅ 仍然存在，可再次发布
广场：（空）
```

---

## 🎯 UI 判断逻辑

### 判断"是否已发布"

**修改前**：
```swift
if poem.inSquare {
    // 显示【已发布广场】
}
```
❌ **问题**：编辑详情页展示的是诗集中的诗（`inSquare = false`），判断错误。

**修改后**：
```swift
if poem.squareId != nil {
    // 显示【已发布广场】
}
```
✅ **正确**：通过 `squareId` 判断，只要诗集中的诗有 `squareId`，说明已发布过。

---

## 📝 修改的文件

### 1. `PoemManager.swift`

**修改**：
- `publishToSquare()` 方法完全重写
- 创建新副本而不是修改标志位
- 记录 `squareId` 进行关联

---

### 2. `PoemEditorDetailView.swift`

**修改**：
```swift
// 判断是否已发布
if poem.squareId != nil {  // ✅ 新逻辑
    // 已发布状态
}
```

---

### 3. `ShareSheet.swift`

**修改**：
```swift
// 只有未发布的才显示【分享到广场】按钮
if poem.squareId == nil {  // ✅ 新逻辑
    // 显示发布按钮
}
```

---

## ✅ 验证结果

### 测试场景

1. ✅ **创作并保存**
   - 诗歌进入【我的-诗集】
   - 显示【发布到广场】按钮

2. ✅ **发布到广场**
   - 创建广场副本
   - 诗集中显示【已发布广场】（灰色）
   - 广场中可见新诗歌

3. ✅ **编辑诗集中的诗**
   - 修改标题和内容
   - 保存成功
   - 广场上的诗**保持不变** ⭐

4. ✅ **从诗集删除**
   - 诗集中删除
   - 广场上的诗仍然存在

5. ✅ **从广场删除**
   - 广场上删除
   - 诗集中的诗仍然存在
   - 【已发布广场】按钮变为【发布到广场】

---

## 🎉 总结

### 核心改进

- ✅ **真正的独立存储**：诗集和广场是两个完全独立的副本
- ✅ **编辑互不影响**：编辑诗集不会影响广场上的内容
- ✅ **删除互不影响**：从一个地方删除，另一个地方仍然保留
- ✅ **关联可追溯**：通过 `squareId` 可以知道诗歌是否已发布

### 技术亮点

- 使用不同的 `id` 实现真正的副本
- `squareId` 字段巧妙地实现关联关系
- UI 判断逻辑清晰明确

这个方案完美解决了"诗集和广场应该独立"的需求！🎉

